function N(e,s){e.src=s}var G=e=>{var s,l,_,p="The Google Maps JavaScript API",d="google",m="importLibrary",E="__ib__",f=document,w=window,g=w[d]||(w[d]={}),u=g.maps||(g.maps={}),y=new Set,v=new URLSearchParams,b=()=>s||(s=new Promise(async(c,t)=>{await(l=f.createElement("script")),v.set("libraries",[...y]+"");for(_ in e)v.set(_.replace(/[A-Z]/g,i=>"_"+i[0].toLowerCase()),e[_]);v.set("callback",d+".maps."+E),N(l,"https://maps.googleapis.com/maps/api/js?"+v),u[E]=c,l.onerror=()=>s=t(Error(p+" could not load.")),l.nonce=f.querySelector("script[nonce]")?.nonce||"",f.head.append(l)}));u[m]?console.warn(p+" only loads once. Ignoring:",e):u[m]=(c,...t)=>y.add(c)&&b().then(()=>u[m](c,...t))};var j=e=>`The setOptions() function should only be called once. The options passed to the additional call (${JSON.stringify(e)}) will be ignored.`,C=e=>`The google.maps.importLibrary() function is already defined, and @googlemaps/js-api-loader will use the existing function instead of overwriting it. The options passed to setOptions (${JSON.stringify(e)}) will be ignored.`,k="No options were set before calling importLibrary. Make sure to configure the loader using setOptions().",B="There already is a script loading the Google Maps JavaScript API, and no google.maps.importLibrary function is defined. @googlemaps/js-api-loader will proceed to bootstrap the API with the specified options, but the existing script might cause problems using the API. Make sure to remove the script loading the API.",T=!1,A=T?e=>{console.warn(`[@googlemaps/js-api-loader] ${e}`)}:()=>{},x=T?e=>{console.info(`[@googlemaps/js-api-loader] ${e}`)}:()=>{};var $=!1,L=!1;function I(e){if(L){A(j(e));return}J(e),L=!0}async function O(e){if(L||A(k),!window?.google?.maps?.importLibrary)throw new Error("google.maps.importLibrary is not installed.");return await google.maps.importLibrary(e)}function J(e){let s=!!window.google?.maps?.importLibrary;s?x(C(e)):$&&document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]')&&A(B),s||G(e)}function V({setStateUsing:e,debug:s,statePath:l,apiKey:_,filterName:p,reverseGeocodeFields:d,latLngFields:m,types:E,countries:f,isLocation:w,placeField:g,reverseGeocodeUsing:u,hasReverseGeocodeUsing:y=!1,minChars:v,fieldId:b}){let c=document.getElementById(b);return{geocoder:null,mapEl:null,symbols:{"%n":["street_number"],"%z":["postal_code"],"%S":["street_address","route"],"%A1":["administrative_area_level_1"],"%A2":["administrative_area_level_2"],"%A3":["administrative_area_level_3"],"%A4":["administrative_area_level_4"],"%A5":["administrative_area_level_5"],"%a1":["administrative_area_level_1"],"%a2":["administrative_area_level_2"],"%a3":["administrative_area_level_3"],"%a4":["administrative_area_level_4"],"%a5":["administrative_area_level_5"],"%L":["locality","postal_town"],"%D":["sublocality"],"%C":["country"],"%c":["country"],"%p":["premise"],"%P":["premise"]},init:function(t){console.log("geocomplete init"),this.mapEl=t,this.createAutocomplete()},async createAutocomplete(){I({key:_});let{Map:t}=await O("maps"),{PlacesService:i}=await O("places"),n=["address_components","formatted_address","geometry","name"];n.includes(g)||n.push(g);let o={fields:n,strictBounds:!1,types:E};if(c){window.addEventListener("keydown",function(a){if((a.key==="U+000A"||a.key==="Enter"||a.code==="Enter")&&a.target.nodeName==="INPUT"&&a.target.type==="text")return a.preventDefault(),!1},!0);let r=new google.maps.places.Autocomplete(c,o);r.setComponentRestrictions({country:f}),r.addListener("place_changed",()=>{let a=r.getPlace();if(!a.geometry||!a.geometry.location){window.alert("No details available for input: '"+a.name+"'");return}this.setLocation(a),this.updateReverseGeocode(a),this.updateLatLng(a)});let S=document.getElementById(l+"-geolocate");S&&(this.geocoder=new google.maps.Geocoder,S.addEventListener("click",a=>{"geolocation"in navigator&&navigator.geolocation.getCurrentPosition(P=>{var R=P.coords.latitude,D=P.coords.longitude,M={lat:R,lng:D};this.geocoder.geocode({location:M}).then(h=>{h.results[0]&&(c.setAttribute("value",h.results[0].formatted_address),this.setLocation(h.results[0]),this.updateReverseGeocode(h.results[0]),this.updateLatLng(h.results[0]))})})}))}},setLocation:async function(t){if(w?await e(l,{lat:t.geometry.location.lat(),lng:t.geometry.location.lng(),formatted_address:t[g]}):await e(l,t[g]),p){let i=p+".latitude",n=p+".longitude",o=document.getElementById(i),r=document.getElementById(n);o&&r&&(o.setAttribute("value",t.geometry.location.lat().toString()),r.setAttribute("value",t.geometry.location.lng().toString()),await e(i,t.geometry.location.lat().toString()),await e(n,t.geometry.location.lng().toString()))}},updateReverseGeocode:async function(t){if(this.hasReverseGeocode()){if(t.address_components){let i=this.getReplacements(t.address_components);for(let n in d){let o=d[n];for(let r in i)o=o.split(r).join(i[r]);for(let r in this.symbols)o=o.split(r).join("");o=o.trim(),await e(n,o)}}y&&u(t)}},updateLatLng:async function(t){Object.keys(m).length>0&&t.geometry&&(await e(m.lat,t.geometry.location.lat().toString()),await e(m.lng,t.geometry.location.lng().toString()))},getReplacements:function(t){let i={};return t.forEach(n=>{for(let o in this.symbols)this.symbols[o].indexOf(n.types[0])!==-1&&(o===o.toLowerCase()?i[o]=n.short_name:i[o]=n.long_name)}),s&&console.log(i),i},hasReverseGeocode:function(){return Object.keys(d).length>0||y}}}export{V as default};
